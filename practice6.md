## Практическая работа 6

### Выбор БД

**Сервис "Пользователи"** 

Хранение информации о пользователях (имя, email, пароль, адрес, история заказов, предпочтения, роли).  Аутентификация и авторизация пользователей.

**Тип базы данных:** Реляционная база данных (например, PostgreSQL, MySQL).

**Обоснование:**
- Структурированные данные: информация о пользователях имеет четкую структуру.
- Безопасность: важна безопасность данных, особенно паролей.
- Целостность данных: важна целостность данных пользователей.
- Отношения: необходимы отношения между пользователями, заказами, адресами, ролями.

**Альтернативные варианты:** специализированные сервисы аутентификации (Auth0, Firebase Authentication). Удобны для аутентификации, но могут потребовать дополнительную базу данных для хранения дополнительных данных о пользователях.

**Сервис "Управление производством**

Управление производственным процессом, хранение информации о материалах, станках, процессах, планах производства, статусах производства, контроле качества.

**Тип базы данных:** Реляционная база данных (например, PostgreSQL, MySQL).

**Обоснование:** 
- Структурированные данные. Большинство данных о производстве структурированы.
- Сложные отношения между материалами, процессами, станками, сотрудниками, планами производства.
- Транзакционная целостность. Важна для обеспечения согласованности данных о производстве.
- Сложные запросы необходимы для планирования производства, отслеживания статуса производства, анализа эффективности.

**Альтернативные варианты:** Time-Series Database. Для хранения данных о работе станков, температурных режимах и других временных рядов.  Целесообразна для мониторинга и анализа работы оборудования.

**Сервис "Управление складом"** 

Хранение информации о наличии товара на складе (количество, расположение, состояние), материалах, компонентах. Отслеживание перемещений товара и материалов.

**Тип базы данных:** Реляционная база данных (например, PostgreSQL, MySQL).

**Обоснование:**
- Транзакционная целостность критична при изменении количества товара и материалов.
- Атомарность операций. Операции увеличения/уменьшения количества должны быть атомарными.
- Консистентность. Необходимо обеспечивать консистентность данных о запасах.

**Альтернативные варианты:** NoSQL база данных (Redis). Для хранения оперативной информации о текущем количестве товара для быстрого доступа.

**Сервис "Каталог товаров"**

Хранение и предоставление информации о товарах (название, описание, характеристики, цена, материалы, размеры, изображения, категории, производитель). Обеспечение поиска и фильтрации.

**Тип базы данных:** Реляционная база данных (например, PostgreSQL, MySQL).

**Обоснование:**
- Структурированные данные. Каталог продукции состоит из структурированных данных с четко определенными атрибутами.
- Сложные запросы. Требуется поддержка сложных запросов для поиска, фильтрации и сортировки.
- Транзакционная целостность. Важна транзакционная целостность данных, особенно при изменении цен, наличия товара и других атрибутов.
- Необходимы отношения между товарами, категориями, производителями, материалами.

**Альтернативные варианты:** Документоориентированная база данных (MongoDB): Важна при гибкости структуры данных, например, для хранения дополнительных, часто меняющихся атрибутов.  Но это усложнит сложные запросы и поддержку целостности.

**Гибридный подход:** Использовать реляционную БД для основных атрибутов и документоориентированную БД для дополнительных.

**Сервис "Заказы"**

Хранение информации о заказах (состав заказа, статус, адрес доставки, платежная информация, история изменений, данные о производстве). Обработка заказов, управление статусами, интеграция с производством.

**Тип базы данных:** Реляционная база данных (например, PostgreSQL, MySQL).

**Обоснование:**
- Транзакционная целостность критически важна при обработке платежей и изменении статуса заказа.
- Отношения: Связи между заказами, пользователями, товарами, платежами, доставкой, данными о производстве.
- Сложные запросы: Требуются для получения информации о заказах по различным критериям.
- ACID-транзакции: Необходимы для гарантии консистентности.

**Альтернативные варианты:** Документоориентированная база данных (MongoDB). Например, для хранения истории изменений заказа.

**Сервис "Платежи"**

Обработка платежей, интеграция с платежными шлюзами, хранение истории платежей.

**Тип базы данных:** Реляционная база данных (RDBMS) (например, PostgreSQL, MySQL).

**Обоснование:**
- Транзакционная целостность: Критически важна при обработке платежей.
- Безопасность: Важна безопасность данных платежной информации.
- Аудит: Необходим аудит всех операций, связанных с платежами.

**Альтернативные варианты:** использование платежных шлюзов. Можно не хранить платежную информацию в собственной базе данных, а использовать API платежных шлюзов.

**Сервис "Управление логистикой"**

Управление доставкой товаров, отслеживание местоположения, планирование маршрутов, интеграция с транспортными компаниями.

**Тип базы данных:** Реляционная база данных (например, PostgreSQL, MySQL) совместно с геопространственной базой данных (PostGIS, MongoDB с GeoJSON).

**Обоснование:**
- Структурированные данные: информация о доставках, маршрутах.
- Геопространственные данные: необходимо хранить и обрабатывать географические координаты для отслеживания местоположения и планирования маршрутов.
- Связи между заказами, доставками, складами, транспортными компаниями.

### Модели данных

#### Пользователи

**USER**
| Поле | Тип |
| --- | --- |
| user_id | uuid |
| first_name | varchar(50) |
| last_name | varchar(50) |
| middle_name | varchar(50) |
| email | varchar(100) |
| phone | varchar(20) |
| address_id | uuid, nullable |
| role | enum ('customer', ','manager', 'admin') |
| created_at | timestamp |
| updated_at | timestamp |

**ADDRESS**
| Поле | Тип |
| --- | --- |
| address_id | uuid |
| region | varchar(50) |
| city | varchar(50) |
| street | varchar(50) |
| district | varchar(50) |
| postcode | varchar(10) |
| created_at | timestamp |
| updated_at | timestamp |

**Ожидаемый прирост**

| Тип | назначение | Месяц | Квартал |
| --- | --- | --- | --- |
| user | Профиль пользователя | ~ 1000 записей * (1 KB/запись) + ~ 200 записей (изменения) * (0.5 KB/запись) = ~ 1100 KB = ~ 1.1 MB | ~ 3.3 MB |
| address | Адресные данные | ~ 800 записей * (0.5 KB/запись) = ~ 400 KB (предполагаем, что часть пользователей использует один и тот же адрес,либо не указывает адрес) | 1.2 MB |

#### Управление производством

**PRODUCTORDER (производственный заказ)**

| Поле | Тип |
| --- | --- |
| product_order_id | uuid |
| order_id | uuid |
| product_id | uuid |
| quantity | integer |
| start_date | timestamp |
| end_date | timestamp |
| status | enum ('created', ','progress', 'completed', 'canceled') |
| created_at | timestamp |
| updated_at | timestamp |

**MATEARIALREQ (потребность в материале)**

| Поле | Тип |
| --- | --- |
| material_req_id | uuid |
| product_order_id | uuid |
| material_id | uuid |
| quantity | decimal (10,2) |
| init | varchar(50) |
| created_at | timestamp |
| updated_at | timestamp |

**OPERATION (операция)**

| Поле | Тип |
| --- | --- |
| operation_id | uuid |
| product_order_id | uuid |
| stage | integer |
| description | text |
| machine_id | uuid |
| employee_id | uuid |
| duration | integer |
| status | enum ('created', ','progress', 'completed') |
| created_at | timestamp |
| updated_at | timestamp |

**MACHINE (Станки)**

| Поле | Тип |
| --- | --- |
| machine_id | uuid |
| name | varchar(100) |
| description | text |
| status | enum ('active', ','inactive', 'maintenance') |
| created_at | timestamp |
| updated_at | timestamp |

**Ожидаемый прирост**

| Тип | назначение | Месяц | Квартал |
| --- | --- | --- | --- |
| productorder | Производственный заказ | ~ 500 записей * (1 KB/запись) = ~ 500 KB | ~ 1.5 MB |
| materialreq | Требуемый материал | ~ 500 заказов * 5 материалов/заказ * (0.5 KB/запись) = ~ 1250 KB = ~ 1.25 MB | ~ 3.7 MB |
| operation | Производимые операции |~ 500 заказов * 3 операции/заказ * (0.5 KB/запись) = ~ 750 KB | 2.2 MB |
| machine | Инфо о станках | ~ 2 записи * (0.5 KB/запись) = ~ 1 KB | 3 KB |

#### Управление складом

**INVENTORYITEM**
| Поле | Тип |
| --- | --- |
| inventory_item_id | uuid |
| product_id | uuid |
| quantity  | integer |
| location  | varchar(100) |
| created_at | timestamp |
| updated_at | timestamp |

**INVENTORYTRANSACTION**
| Поле | Тип |
| --- | --- |
| inventory_transaction_id | uuid |
| inventory_item_id | uuid |
| transaction_type | enum('in', 'out', 'adjustment') |
| quantity  | integer |
| reason | text |
| created_at | timestamp |
| updated_at | timestamp |

**Ожидаемый прирост**

| Тип | назначение | Месяц | Квартал |
| --- | --- | --- | --- |
| inventoryitem | Запасы на складе  | 50 новых товаров * (0.5 KB/запись) = ~ 25 KB | ~ 75 KB |
| inventorytrancsaction | Транзакция по запасу | ~ 500 заказов * 2 транзакции/заказ * (0.5 KB/запись) + ~ 100 корректировок * (0.5 KB/запись) = ~ 550 KB | 1.6 MB |

#### Каталог товаров

**PRODUCT**

| Поле | Тип |
| --- | --- |
| product_id | uuid |
| name | varchar(50) |
| description | text |
| price | varchar(50) |
| category_id | uuid |
| brand_id | uuid |
| materials | jsonb |
| proportions | jsonb |
| images | jsonArray |
| status | enum ('active', ','inactive', 'discontinued') |
| created_at | timestamp |
| updated_at | timestamp |

**CATEGORY**

| Поле | Тип |
| --- | --- |
| category_id | uuid |
| name | varchar(50) |
| description | text |
| parent_category_id | uuid |
| created_at | timestamp |
| updated_at | timestamp |

**BRAND**

| Поле | Тип |
| --- | --- |
| brand_id | uuid |
| name | varchar(50) |
| description | text |
| logo_url | varchar |
| created_at | timestamp |
| updated_at | timestamp |

**MATERIAL**

| Поле | Тип |
| --- | --- |
| material_id | uuid |
| name | varchar(100) |
| description | text |
| properties | jsonb |
| created_at | timestamp |
| updated_at | timestamp |

**Ожидаемый прирост**

| Тип | назначение | Месяц | Квартал |
| --- | --- | --- | --- |
| product | Товар | ~ 50 записей (изменения + новые) * (1-2 KB/запись) = ~ 50-100 KB | ~ 150-300 KB |
| category | Категории товаров | ~ 10 записей * (0.5 KB/запись) = ~ 5 KB | ~ 15 KB |
| brand | Бренды товаров |~ 2 записи * (0.5 KB/запись) = ~ 1 KB | 3 KB |
| material | Материал изготовления товара | ~ 5 записей * (0.5 KB/запись) = ~ 2.5 KB | 7.5 KB |

#### Заказы

**ORDER**

| Поле | Тип |
| --- | --- |
| order_id | uuid |
| user_id | uuid |
| order_date | timestamp
| total_amount | decimal(10,2) | 
| shipping_address_id | uuid |
| billing_address_id | uuid |
| status | enum ('pending', 'processing', 'shipped', 'delivered', 'cancelled') |
| bpayment_method | enum ('credit_card', 'paypal', 'bank_transfer') |
| created_at | timestamp |
| updated_at | timestamp |

**ORDERITEM**

| Поле | Тип |
| --- | --- |
| order_item_id | uuid |
| order_id | uuid |
| product_id | uuid |
| quantity | integer |
| price  | decimal(10,2) |
| created_at | timestamp |
| updated_at | timestamp |

**SHIPPINGADDRESS**

| Поле | Тип |
| --- | --- |
| shipping_address_id | uuid |
| region | varchar(50) |
| city | varchar(50) |
| street | varchar(50) |
| district | varchar(50) |
| postcode | varchar(10) |
| created_at | timestamp |
| updated_at | timestamp |

**BILLINGADDRESS**

| Поле | Тип |
| --- | --- |
| billing_address_id | uuid |
| region | varchar(50) |
| city | varchar(50) |
| street | varchar(50) |
| district | varchar(50) |
| postcode | varchar(10) |
| created_at | timestamp |
| updated_at | timestamp |

**Ожидаемый прирост**

| Тип | назначение | Месяц | Квартал |
| --- | --- | --- | --- |
| order | Информация о заказе | ~ 500 записей * (1 KB/запись) = ~ 500 KB | ~ 1.5 MB |
| orderitem | Позиции в заказе | ~ 500 заказов * 3 товара/заказ * (0.5 KB/запись) = ~ 750 KB | ~ 2.2 MB |
| shippingaddress | Адреса доставки |~ 400 записей * (0.5 KB/запись) = ~ 200 KB (часть адресов совпадает с существующими) | 800 KB |
| billingaddress | Выставление счета | ~ 400 записей * (0.5 KB/запись) = ~ 200 KB (часть адресов совпадает с существующими) | 600 KB |

#### Платежи

**PAYMENT**

| Поле | Тип |
| --- | --- |
| payment_id | uuid |
| order_id | uuid |
| payment_date | timestamp |
| amount | decimal(10,2) |
| payment_method | enum ('credit_card', 'paypal', 'bank_transfer') |
| transaction_id | varchar(50) |
| status | enum ('pending', 'approved', 'declined', 'refunded') |
| created_at | timestamp |
| updated_at | timestamp |


**Ожидаемый прирост**

| Тип | назначение | Месяц | Квартал |
| --- | --- | --- | --- |
| payment | Информация о платеже | ~ 500 записей * (1 KB/запись) = ~ 500 KB | ~ 1.5 MB |

#### Управление логистикой

**DELIVERY**

| Поле | Тип |
| --- | --- |
| delivery_id | uuid |
| order_id | uuid |
| shipping_address_id | uuid |
| tracking_number | varchar(50) |
| carrier  | varchar(50) |
| status | enum ('pending', 'in_transit', 'delivered', 'failed') |
| expected_delivery_date | date |
| actual_delivery_date | date |
| created_at | timestamp |
| updated_at | timestamp |

**DELIVERYEVENT**

| Поле | Тип |
| --- | --- |
| delivery_event_id | uuid |
| delivery_id | uuid |
| event_time | timestamp |
| location  | GEOGRAPHYPOINT |
| description  | text |
| status | enum ('pending', 'approved', 'declined', 'refunded') |
| created_at | timestamp |
| updated_at | timestamp |


**Ожидаемый прирост**

| Тип | назначение | Месяц | Квартал |
| --- | --- | --- | --- |
| delivery | Информация о доставке | ~ 500 записей * (1 KB/запись) = ~ 500 KB | ~ 1.5 MB |
| deliveryevent | Информация о событии доставки |~ 500 доставок * 5 событий/доставка * (0.5 KB/запись) = ~ 1250 KB = ~ 1.25 MB | ~ 3.7 MB |


### Клиент делает заказ на 20 штук, но на одном складе нужного количества нет. Как собрать заказ так, чтобы в процессе всё было согласованно, мы могли ответить клиенту, что всё в наличии, и в процессе этой операции кто-то другой не выкупил бы товар на одном из складов? Как вы будете решать такую задачу? Опишите и обоснуйте стратегию решения. Какие риски и последствия вы видите?

>![Результат 1](/seq3.png)

**Стратегия Решения:**

Клиент делает заказ на 20 штук товара А. Сервис заказов получает запрос и инициирует процесс проверки доступности на всех складах.
**Агрегация Данных о Запасах:** Система опрашивает каждый склад (Склад 1, Склад 2, Склад 3) и собирает информацию о доступном количестве товара А.  В контексте задачи:
- Склад 1: 10 штук
- Склад 2: 5 штук
- Склад 3: 8 штук

**Проверка возможности выполнения заказа:** Система суммирует запасы со всех складов (10 + 5 + 8 = 23).  Поскольку общее количество больше или равно количеству в заказе, заказ принципиально может быть выполнен.

**Распределенная Транзакция (Резервирование):**

Начало Транзакции: Инициируется распределенная транзакция, охватывающая все склады, участвующие в выполнении заказа.
Резервирование на Складах: Система последовательно или параллельно отправляет запросы на резервирование товара на каждый склад:
- Склад 1: Резервируется 10 штук.
- Склад 2: Резервируется 5 штук.
- Склад 3: Резервируется 5 штук (остается 3 штуки на складе).  

Система оптимизирует резервирование, чтобы использовать минимальное количество складов.

**Временное уменьшение запасов:** На каждом складе запасы временно уменьшаются на зарезервированное количество, но изменения **не фиксируются** окончательно.
**Двойная проверка доступности:**  Перед фиксацией транзакции система повторно проверяет доступность товара А на каждом складе, участвующем в транзакции. Это необходимо, чтобы учесть возможные параллельные заказы.

**Результат:**

- Успех: Если повторная проверка подтверждает, что все зарезервированные количества все еще доступны, система отправляет клиенту подтверждение о выполнении заказа.
- Ошибка: Если на каком-либо складе товар стал недоступен, транзакция откатывается (см. ниже).

**Фиксация транзакции:** 

- Если все проверки прошли успешно, система отправляет команды на фиксацию транзакции на каждый склад. Запасы на складах окончательно уменьшаются.
- Если на каком-либо этапе (например, во время повторной проверки доступности) возникает ошибка, система выполняет откат транзакции. В этом случае система отправляет команды на отмену резервирования на все склады, участвующие в транзакции.
Запасы на складах возвращаются к исходному состоянию.

Система уведомляет клиента о том, что заказ не может быть выполнен из-за нехватки товара.

**Обоснование Стратегии:**

- Минимизация Риска Over-Selling: Двойная проверка доступности перед фиксацией транзакции сводит к минимуму риск того, что система продаст больше товара, чем есть в наличии.
- Оптимальное распределение: Система пытается использовать минимальное количество складов для выполнения заказа, что может снизить затраты на логистику.
- Атомарность: Распределенная транзакция гарантирует, что заказ либо будет выполнен полностью, либо не будет выполнен вообще.  Это предотвращает ситуации, когда часть заказа выполнена, а часть – нет.
- Консистентность: Данные о запасах на всех складах остаются консистентными.

**Риски и последствия :**

- Реализация распределенных транзакций с несколькими складами более сложна.  Необходимо тщательно проектировать логику транзакций и обработку ошибок.
-  Запросы к нескольким складам и необходимость координации транзакций могут существенно повлиять на производительность. Необходимо оптимизировать запросы, использовать кеширование и асинхронную обработку.
- Надежность системы сильно зависит от стабильности сетевого соединения между системой заказов и складами.  Необходимо предусмотреть механизмы обработки сетевых ошибок и повторных попыток.
- Блокировки могут возникать на складах во время резервирования.  Необходимо использовать механизмы управления блокировками и таймауты для предотвращения deadlocks.
- Тестирование распределенных транзакций с несколькими складами требует использование методов имитационного тестирования и нагрузочного тестирования для выявления проблем.
- Важно обеспечить синхронизацию данных о запасах между складами и системой заказов.  Необходимо использовать механизмы репликации и консистентности данных.

### Всё то же самое, что и в предыдущем вопросе, но теперь на складе 3 всего две единицы товара А. Как вы будете решать такую задачу? Опишите и обоснуйте стратегию решения. Какие риски и последствия вы видите?

>![Результат 2](/seq1.png)

**Стратегия Решения :**

Клиент делает заказ на 20 штук товара А. Система заказов получает запрос и инициирует процесс проверки доступности на всех складах.

**Агрегация Данных о Запасах**: Система опрашивает каждый склад (Склад 1, Склад 2, Склад 3) и собирает информацию о доступном количестве товара А. В контексте задачи:
- Склад 1: 10 штук
- Склад 2: 5 штук
- Склад 3: 2 штук

Система суммирует запасы со всех складов (10 + 5 + 2 = 17).  Поскольку общее количество  меньше количества в заказе , заказ в полном объеме не может быть выполнен.

**Варианты для клиента**

1. Предложить частичное выполнение: Система предлагает клиенту выполнить заказ частично, на максимально доступное количество (17 штук).

Инициируется распределенная транзакция на резервирование максимально доступного количества товара (17 штук):
- Склад 1: Резервируется 10 штук.
- Склад 2: Резервируется 5 штук.
- Склад 3: Резервируется 2 штуки.

**Двойная проверка доступности:**  Перед фиксацией транзакции система повторно проверяет доступность товара А на каждом складе, участвующем в транзакции.
**Фиксация Транзакции**: 
- Если все проверки прошли успешно, система отправляет команды на фиксацию транзакции на каждый склад. Запасы на складах окончательно уменьшаются.  Система уведомляет клиента о том, что заказ выполнен частично (17 штук из 20).
- Откат Транзакции (Ошибка):  Если на каком-либо этапе возникает ошибка, система выполняет откат транзакции.

2. Предложить подождать поступления товара: Если клиент согласен подождать, система может предложить выполнить заказ после поступления недостающего количества товара на один из складов.

Дальнейшие действия зависят от выбранного сценария (поступление товара, наличие альтернативы)

3. Предложить альтернативный товар:  Предложить клиенту похожий товар, который есть в наличии в необходимом количестве.
4. Отменить заказ: Если ни один из вышеперечисленных вариантов не подходит клиенту, система отменяет заказ.

Если Клиент Отказывается от Заказа: Заказ отменяется, и никакие действия на складах не производятся.

**Обоснование стратегии:**

- Ориентация на клиента:  Стратегия предполагает несколько вариантов решения и оставляет выбор за клиентом.
- Предотвращение "Over-Selling": тщательная инвентаризация и распределенная транзакция предотвращают продажу большего количества товара, чем доступно.
- Стратегия позволяет обрабатывать различные сценарии (частичное выполнение, ожидание, альтернативный товар).
- Оптимизация ресурсов: Система пытается максимально использовать доступные ресурсы (запасы на складах), но при этом не обещает того, что не может выполнить.

**Риски:**

- Неудовлетворенность клиента:  Клиент может быть разочарован тем, что заказ не выполнен в полном объеме. Важно предложить компенсацию (например, скидку на следующий заказ) или альтернативные варианты.
- Сложность учета частичных заказов: необходимо тщательно отслеживать частичные заказы и остатки, чтобы правильно управлять запасами.
- Частичные заказы могут усложнить логистику, особенно если клиенту необходимо получить товар с разных складов.
- Обработка вопросов и претензий, связанных с частичными заказами, может увеличить нагрузку на службу поддержки.
- Если клиент отказывается от частичного выполнения, компания теряет продажу.


### Cинхронизация цен на нескольких витринах

>![Результат 3](/seq5.png)

**Стратегия cинхронизации цен**:

Для обеспечения консистентности цен на нескольких сайтах-витринах, необходимо использовать механизм синхронизации данных. 

**Централизованное хранилище цен:**
Все цены на товары хранятся в одном централизованном хранилище данных. Это может быть специализированная база данных для цен (например, с поддержкой версионности), либо часть основной базы данных каталога товаров. 

**Событийная Модель (Event-Driven Architecture):**

Когда администратор изменяет цену на товар, система генерирует событие.
Это событие публикуется в центральный брокер сообщений (Message Broker), такой как Kafka, RabbitMQ, или аналогичный.

**Подписка сайтов-витрин на события:**

Каждый сайт-витрина подписывается на события из брокера сообщений.
Когда сайт-витрина получает событие, он обновляет цену на соответствующий товар в своем локальном кэше или базе данных.

**Локальное Кэширование на Сайтах-Витринах (Cache-Aside Pattern):**

Сайты-витрины не запрашивают цены напрямую из центрального хранилища при каждом запросе пользователя. Вместо этого, они используют локальный кэш.
При получении события, кэш на соответствующем сайте-витрине обновляется.
При следующем запросе цены на этот товар, сайт-витрина проверит, есть ли цена в кэше. Если нет, он запросит цену из центрального хранилища, обновит кэш, и вернет цену пользователю.

**Консистентность**

- Идемпотентность обработчиков событий: Обработчики событий на сайтах-витринах должны быть идемпотентными. 
- Упорядоченная доставка событий: Брокер сообщений должен гарантировать, что события доставляются в том порядке, в котором они были опубликованы. Это важно для того, чтобы избежать ситуаций, когда более старые версии цен перезаписывают более новые.
- Таймауты и повторные попытки: При возникновении ошибок при обработке событий, система должна использовать таймауты и повторные попытки. Это позволяет справиться с временными проблемами с сетью или недоступностью центрального хранилища.

**Фоновые проверки консистентности :**

- Периодически (например, раз в час или раз в день) запускается фоновый процесс, который проверяет консистентность цен на всех сайтах-витринах.
Этот процесс запрашивает цены из центрального хранилища и сравнивает их с ценами в локальных кэшах. Если обнаруживаются расхождения, то цены в кэшах обновляются.

**Риски:**

- Требует опыта работы с брокерами сообщений, кэшированием и распределенными системами.
- Задержка обновления: Хотя задержка обычно минимальна, небольшая задержка в обновлении цен все же возможна.
- Использование брокера сообщений может потребовать дополнительных затрат на инфраструктуру.
- Важно мониторить систему, чтобы выявлять и устранять проблемы с синхронизацией цен.

### Если клиент кладёт товар со скидкой, то он 100% должен заплатить указанную цену, при этом фирма не должна потерять деньги на доставке с другого отдалённого склада.

>![Результат 4](/seq6.png)

**Резервирование товара при добавлении в корзину:**

Когда клиент добавляет товар в корзину, система должна сразу зарезервировать это количество товара на складе, ближайшем к клиенту, или на складе, с которого изначально была предложена скидка.
Резервирование означает, что этот товар больше не доступен для покупки другими клиентами.
Резервирование должно быть ограничено по времени (например, 15-30 минут).

**Фиксация цены при резервировании:**

В момент резервирования товара в корзине, система должна зафиксировать цену этого товара (включая скидку).  Эта цена становится гарантированной для клиента в течение срока резервирования.
Зафиксированная цена сохраняется вместе с информацией о резервировании.

**Динамический расчет логистических затрат при оформлении заказа:**

Когда клиент переходит к оформлению заказа, система должна повторно проверить доступность товара на складе, с которого был зарезервирован товар.
Если товар все еще доступен на этом складе, то используется зафиксированная цена, и оформление заказа продолжается.
Если товар больше не доступен на этом складе (его выкупили другие клиенты за время резервирования), то система должна:
- Автоматически рассчитать стоимость доставки товара с ближайшего доступного склада.
- Сравнить новую стоимость (цена товара + доставка с другого склада) с зафиксированной ценой.

Если новая стоимость не превышает зафиксированную цену, то оформление заказа продолжается с доставкой с другого склада (компания покрывает разницу).

Если новая стоимость превышает зафиксированную цену, то система должна предложить клиенту один из следующих вариантов:

1. Уведомить клиента о том, что товар был раскуплен на ближайшем складе, и предложить купить товар по новой цене (с доставкой с другого склада). Клиент может принять или отклонить предложение.  Важно прозрачно объяснить причину изменения цены.
2. Предложить клиенту дождаться поступления товара на ближайший склад (если это возможно).
3. Аннулировать заказ.

**Обработка таймаута резервирования:**

Если клиент не оформил заказ в течение срока резервирования, система должна освободить зарезервированный товар и снять фиксацию цены.

**Обоснование:**

- Резервирование товара предотвращает ситуацию, когда товар, добавленный в корзину, выкупается другим клиентом, пока первый клиент оформляет заказ.
- Фиксация цены гарантирует, что цена, которую видит клиент при добавлении товара в корзину, останется неизменной в течение срока резервирования.  Это повышает доверие клиента к магазину.
- Динамический расчет логистики позволяет избежать убытков из-за доставки товара с удаленных складов, если товар на ближайшем складе закончился.
- В случае изменения цены (из-за отсутствия товара на ближайшем складе), клиент получает четкое объяснение причины и имеет возможность принять решение о покупке по новой цене или отказаться от заказа. Это минимизирует негативные эмоции и сохраняет репутацию магазина.

**Риски:**

- Требуется более сложная логика управления запасами, ценами и логистикой.
- Если товар заканчивается на складе, клиент может столкнуться с необходимостью заплатить больше или отказаться от заказа.  Однако, это компенсируется прозрачностью и объяснением причины.
- Если срок резервирования слишком велик, это может привести к блокировке значительного количества товаров и снижению продаж.  Важно правильно настроить срок резервирования.